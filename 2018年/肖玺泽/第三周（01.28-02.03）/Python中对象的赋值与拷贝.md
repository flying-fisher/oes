# Python中对象的赋值与拷贝

- Python中，对象的赋值与拷贝（浅拷贝/深拷贝）之间存在差异，使用时不注意可能产生意外结果
- 以下list对象obj1为例，对赋值、浅拷贝和深拷贝进行说明

## 对象赋值

- 对象的赋值都是**地址传递**

```python
>>> obj1 = ['test', 5, ['Python','Java']]
>>> obj2 = obj1

>>> print(id(obj1),[id(item) for item in obj1])
2000910763080 [2000905687144, 1787411024, 2000911360264]
>>> print(id(obj2),[id(item) for item in obj2])
2000910763080 [2000905687144, 1787411024, 2000911360264]
>>> obj2[0] = 'test2'	#str等为不可变类型，修改会使用新的对象替代，得到新的地址
>>> print(id(obj2),[id(item) for item in obj2])
2000910763080 [2000905546360, 1787411024, 2000911360264]
```

## 拷贝

- Copy操作意味着两个在内存中不同的对象，所以对应的id也是不一样的

### 浅拷贝

- 浅拷贝会创建一个新的对象
- 对于对象容器中的元素，浅拷贝就只会使用原始引用
  - 修改容器中的元素会同样影响原对象

```python
>>> import copy
>>> obj3 = copy.copy(obj1)
>>> print(id(obj3),[id(item) for item in obj3])
2000911046664 [2000905687144, 1787411024, 2000911360264]
```

**产生浅拷贝效果的操作**

1. copy.copy(obj)

2. 工厂函数(list/set等)

   ```python
   >>> obj5 = list(obj1)
   >>> print(id(obj5),[id(item) for item in obj5])
   2000911427784 [2000905546360, 1787411024, 2000911360264]
   ```

3. 切片

   ```python
   >>> obj6 = obj1[:]
   >>> print(id(obj6),[id(item) for item in obj6])
   2000910947272 [2000905546360, 1787411024, 2000911360264]
   ```

### 深拷贝

- 深拷贝会创建一个新的对象
- 对于容器中的不可变类元素，使用原始引用
  - 不可变类对象没有必要在内存中存在相同的两个，因此无法被拷贝
  - 非容器类int，float，str等，修改时会使用新的对象替代，得到新的地址
  - 不可变类容器（tuple等），同样无法被拷贝
- 对于容器中的其他元素，继续进行深拷贝

```python
>>> obj4 = copy.deepcopy(obj1)
>>> print(id(obj4),[id(item) for item in obj4])
2000911035528 [2000905687144, 1787411024, 2000911045960]
```

## 图示

![Python对象的赋值与拷贝](.\Python对象的赋值与拷贝.png)

参考www.cnblogs.com/wilber2013/p/4645353.html