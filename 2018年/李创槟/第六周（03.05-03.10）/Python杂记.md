# 初识python

1.  **安装python3**



1.  Linux和Mac OS会预装Python2

2.  Windows未内置任何python版本

3.  要看python的版本，在windows可以

    C:\\python3\\python.exe -V

4.  如果没有-V，则进入python解释器，使用quit()退出解释器



2.  **处理复杂数据**



1.  为了降低复杂性，通常可以把数据组织为列表，python中可以很容易地利用代码创建和处理列表list



3.  **创建简单的python列表**



1.  为了将人可读的列表转换为python可读的列表，需要：

    a.  在数据两边加引号（“”），转换为字符串

    b.  用逗号(,)将列表项与下一项分隔开

    c.  在列表两边加上开始和结束中括号(\[\])

    d.  使用赋值操作符(=)将列表赋至一个标识符

        **注、python的变量标识符没有类型**



1.  在Python中，标识符只是名字

2.  可以把python的列表想象成一个高层集合，数据项的类型并不重要

3.  Python要知道的只是你需要一个列表，而且为它指定了一个名字，另外这个列表包含一些数据项



4.  **列表就像数组**



1.  在python中创建一个列表时，解释器会在内存中创建一个类似数组的数据结构来存储数据，数据项自下而上堆放（形成一个堆栈）。

2.  类似于其他编程语言中的数组，堆栈中的第一个槽编号为0，第二个槽编号为1...

3.  也就是列表中每个数据项都有一个与之关联的数值偏移量（offset）



5.  **使用中括号记法访问列表数据**



1.  像数组一样，可以使用中括号偏移量记法来访问一个列表槽中的数据项：

    a.  print(movies\[1\])

2.  print(len(movies))

    a.  对一个内建函数（BIF）的结果再调用另一个内建函数完全可以

3.  len()的作用是判断一个列表的长度

4.  print()的作用是在屏幕上显示一个数据项

5.  append()在列表末尾增加一个数据项

6.  pop()从列表末尾删除一个数据项

7.  extend()在列表末尾增加一个列表

8.  remove(“xxx”)在列表找到并删除一个特定的数据项

9.  insert(y,”xxx”)在y位置的前面增加一个数据项



6.  **python列表可以包含混合类型的数据**



1.  在同一个python列表中混合存放字符串和数字是允许的，或者混合任意类型的数据

2.  在小列表中如果要增加若干数据，不如从头重新创建列表



7.  **处理列表数据**



1.  python提供了一个内置的for循环可以方便地迭代一个列表

    for item in items:

    code

2.  其中item作为一个列表中当前迭代到的数据项，items即列表的标识符

3.  使用for循环是可伸缩的，适用于任意大小的列表

4.  使用for时，将由python解释器考虑状态信息

5.  使用while循环也可以达到一样的效果

    count = 0

    whle cound &lt; len(items):

    print(items\[count\])

    count = count + 1

    **Question、问题**

6.  python是可伸缩的，但也支持越界检查，因为如果访问一个本来就不存在的数据，就能检测到，并报错

7.  在python中，单引号或双引号都可以创建字符串，但有一个规则：

    a.  如果字符串前面使用了某种引号，后面也要使用同一种进行匹配

8.  在一个字符串中嵌入一个双引号有两种方法：

    a.  使用\\”进行转义

    b.  用单引号引起双引号

9.  Python的标识符也有必须遵守的规则：

    a.  名字可以以字母或下划线(\_)开头

    b.  接下来可以由任意多个字母、数字、斜杠/、下划线\_组成

    c.  不允许有其他符号，如%\$

10. Python属于大小写敏感的语言，区分大小写



8.  **在列表中存储列表**



1.  列表中除了可以放数据项外，同样可以放其他列表

2.  列表可以多层嵌套，就像多维数组一样

3.  访问嵌套数据项，同样用中括号记法访问，如movies\[4\]\[1\]\[3\]

4.  在for循环中，嵌套列表被视为数据项打印



9.  **在列表中查找列表**



1.  isinstance内建函数允许检查某个特定标识符是否包含某个特定类型的数据

    a.  isinstance(name,list)检查name中是否包含列表

2.  因此可以通过isinstance和if-else遍历双层列表，但改进不大

3.  Python3有70多个内建函数



10. **创建一个函数**



1.  Python中创建函数的语句为：

    def &lt;函数名&gt; (\[参数,参数2,...\]):

    代码组

2.  其中，参数可以没有，也可以有无数个，但括号不能没有



11. **递归**



1.  要处理列表中嵌套列表的情况，可以使用递归

2.  **Python3默认递归深度不能超高100**



12. **python术语**



1.  BIF----内置函数

2.  组（suite）----python代码块，会通过缩进来指示分组

# 函数模块

1.  **函数转换为模块**



1.  模块就是一个包含python代码的文本文件。

2.  **对模块的主要需求就是要求文件名以.py结尾**

3.  Python标准库里已经预加载了大量的模块，在python安装完就有了

4.  如果标准库里没有，也可以网上下载别人的python模块

5.  Python包索引（PyPI）是Internet上的第三方Python模块提供了一个集中的存储库



2.  **注释代码**



1.  通过使用三重单或双引号给代码加注释，相当于java的/\*\*/

    “””这里是注释”””

2.  通过井号\#可以注释单行代码，相当于java的//

    \#这里是注释

3.  通过代码import sys; sys.path可以知道python模块在计算机上的位置

4.  Python中可以通过分号(;)把代码放在同一行，但是可读性就差了



3.  **准备发布**



1.  为模块创建一个文件夹

2.  在文件夹中创建一个名为setup.py的文件

    a.  这个文件包含有关发布的元数据

    b.  代码如下：

        from distutils.core import setup \#从python发布工具导入setup函数

        setup( \#增加元数据键值对

        name = ‘xxx’

        version = ‘x.x.x’

        py\_modules = \[‘xxx’\],

        author = ‘xxx’,

        author\_email = *‘xxx@xx.xxx’*

        url = ‘http://xxx.xxx.xxx’,

        description = ‘xxxxxx’,

        )



4.  **构建发布**



1.  构建一个发布文件

    a.  进入模块文件夹

    b.  键入命令python3 setup.py sdist

2.  将发布安装到python本地副本中

    a.  键入命令sudo python3 setup.py install



5.  **发布速览**



1.  发布前，只有两个文件：

    a.  文件夹名xxx

        i.  xxx.py：存放代码

        ii. setup.py：存放元数据

2.  发布后，多了以下：

    a.  文件夹名xxx

        i.  MANIFEST：这个文件包含发布中的文件列表

        ii. build文件夹

            1.  lib文件夹

                a.  xxx.py：存放代码

        iii. dist文件夹

            1.  xxx-x.x.x.tar.gz：发布包

        iv. xxx.py：存放代码

        v.  xxx.pyc：”编译”版本的代码，类似于java的class文件，可以完成运行时优化，删除后只会影响运行时优化，但不能作为执行文件，只有py可以执行

        vi. setup.py：存放元数据



6.  **导入模块并使用**



1.  要使用一个模块，就要导入到程序中，使用关键字import

    import xxx \#导入模块时不需要包含.py扩展名

2.  xxx为setup.py中定义的模块名



7.  **python的模块实现命名空间**



1.  python的所有代码都与一个命名空间关联，命名空间就像人的姓氏

2.  主python程序中的代码与一个名为\_\_main\_\_的命名空间关联

3.  将代码放在其单独的模块中时，python会自动创建一个与模块同名的命名空间。

4.  导入模块后，要使用模块中的函数，就需要加入模块的命名空间

    xxx.method(args) \#xxx为模块名，点号将函数名与命名空间分割

5.  使用普通的import与语句，python解释器就允许使用命名空间访问模块中的函数

6.  如果使用from xxx import method，就不必再使用命名空间限定

    a.  **但是如果原来就有method这个方法，就会覆盖**



8.  **一些内置函数**



1.  在程序中使用BIF，不需要有任何导入

2.  BIF的命名空间为\_\_builtins\_\_，但会自动导入\_\_main\_\_

3.  list()：工厂函数，创建一个新的空列表

4.  range()：返回一个迭代器，根据需求生成一个指定范围的数字

5.  enumerate()：创建成对数据的一个编号列表，从0开始

6.  int()：将一个字符串或另一个数转换为一个整数（如果可以转）

7.  id()：返回一个python数据对象的唯一标识

8.  next()：返回一个可迭代数据结构（如列表）中的下一项



9.  **range()迭代函数**



1.  可以控制迭代指定次数：

    for num in range(4):

    print(num)

    2、输出0、1、2、3、4

    **十、print()输出函数**

    1、print默认换行\\n

    2、可以使用print(“xxxx”,end=’’)输出xxxx而不换行

    **十一、pyhton会尽力运行你的代码**

    1、python在运行之前并不全面检查代码的合法性，因此可以做到很多其他语言做不到的事，比如运行时动态地定义函数

    1）相当灵活，也相当强大

    2）但相对的，编写代码时就要特别小心，一些有错误的地方很可能不会被检查到

    **十二、更新模块**

1、如果修改了模块，可以对setup.py中的version进行调整，表示新版本

**十三、使用可选参数**

1、为了将一个函数的必要参数变成可选参数，需要为这个参数提供一个缺省值，如果没有提供参数值，就会使用这个缺省值；如果提供了一个参数值，则会使用这个值而不是缺省值。

# 文件与异常

1.  **程序外部的数据**



1.  大多数程序都遵循输入-处理-输出模型：

    a.  输入数据

    b.  进行处理

    c.  存储、显示、打印或传输



2.  **都是文本行**



1.  python中的基本输入进制是基于行的：从文本文件向程序读入数据时，一次会到达一个数据行

2.  Python的BIF：open()就是用来与文件交互的，创建一个迭代器从文件想你的代码输入数据行，一次传入一行数据

3.  Python的BIF：close()关闭文件



3.  **一些输入输出函数**



1.  从标准库导入os

    a.  os.getcwd()：输出当前目录

    b.  os.chdir(‘目录’)：切换当前目录到对应目录

2.  readline()方法：从文件读取一个数据行，返回字符串

3.  seek(0)方法：返回文件起始位置

4.  split(“分隔符”)：返回一个字符串列表，由原字符串分割而来

    a.  可以有多一个参数split(“分隔符”,1)：为1则只分隔为两部分

5.  find(“子串”)：在一个字符串找一个子串

    a.  如果找不到，返回-1

    b.  找到了，则返回该子串在原串的索引位置



4.  **多重赋值**



1.  字符串列表可以赋值给一个目标标识符列表

    (arg1, arg2) = str.split(“:”)



5.  **请求帮助**



1.  调用help(标识符.函数名)可以请求帮助，找到关于函数的信息

2.  If not xxx：通过not可以将原来的返回条件取反，相当于!



6.  **处理异常**



1.  代码出问题时，python解释器会显示一个traceback，后面跟着一个错误信息。在python中，运行时错误叫异常（exception）

    a.  如果决定在异常出现时将其忽略，你的程序将会崩溃

2.  事实上，python允许在异常发生时捕获异常，这样就可以从错误中恢复，并避免崩溃。通过控制程序的运行时行为，可以确保程序面对大多数异常时是健壮的



7.  **先尝试，然后恢复**



1.  并非增加额外的代码和逻辑来阻止不好的事情发生，python的异常处理机制允许错误出现，但监视它的发生，然后给你一个机会来恢复。

    a.  在正常控制流期间，python尝试运行你的代码，如果没有任何问题，代码会继续正常执行。

    b.  在异常控制流期间，python先尝试运行你的代码，如果发现有问题，就会执行恢复代码，然后继续执行你的代码。



8.  **try/except机制**



1.  python有一个try语句，这个语句提供了在运行时系统地处理异常和错误的途径。

2.  try和except都是python关键字

    try:

    可能导致运行时错误的代码。

    except：

    错误恢复代码。



9.  **找出要保护的代码**



1.  python中实际有两种类型的列表：一种是可以改变的列表（用中括号包围）；另一种一旦创建就不能改变（用小括号包围），这是不可变列表，更常见的称呼是元组（tuple）。可以认为元组是一个常量列表



10. **放过错误**



1.  在捕获异常时，不希望做一些什么，就是用python的pass语句（也可以任务是空语句或null语句）



11. **额外代码处理异常**



1.  额外代码通过确保运行时错误根本不会发生，保证代码充分安全，绝对不会遭遇traceback

2.  致命缺点是以增加复杂性为代价，而且错误是无法保证绝对不会发生的

3.  额外的代码越来越多，将会掩盖程序的本来作用；而异常处理可以一目了然地看出程序的主要作用。

4.  因此，谨慎地使用try语句可以让代码更易读，更易写，出问题时也更容易修正。



12. **特定指定异常**



1.  如果异常处理代码设计为处理一种特定类型的错误，一定要在except代码行上指定错误类型。这样就可以把一般化的异常处理代码变为具有特定性

2.  虽然这样代码将不再处理不同类型的错误，但是不会再忽略掉特定的运行时错误了

# 持久存储

1.  **以写模式打开文件**



1.  使用open()BIF打开磁盘文件时，可以指定使用什么访问模式。

2.  **默认地，open()使用模式r表示读，所以不需要专门制定r模式**

3.  要打开一个文件完成写，需要使用模式w:

    a.  out = open(“data.out”,”w”)

    b.  其中前面的out为数据文件对象，data为文件名

4.  默认地，print()BIF显示数据时会使用标准输出（通常是屏幕）。要把数据写至一个文件，需要使用file参数指定使用的数据文件对象：

    a.  print(“xxxx”,file=out)

    b.  其中out为数据文件对象

5.  完成工作时，一定要关闭文件，确保所有数据都写至磁盘

    a.  out.close()

    b.  **这称为刷新输出（flushing），非常重要**

6.  注意：

    a.  使用访问模式w时，python会打开指定的文件完成写，如果这个文件已经存在，则会***完全清除***它现有的内容。

    b.  要***追加***到一个文件，需要使用访问模式a。

    c.  要打开一个文件并完成写和读（**不清除**），需要使用w+。

    d.  如果想打开一个不存在的文件完成写，会首先创建这个文件，然后再打开文件进行写。



2.  **用finally扩展try**



1.  不论出现什么错误都必须运行某些代码时，可以向try语句的finally组增加代码：

2.  通常文件的关闭就可以加在finally组中，减少数据破坏错误的可能性。



3.  **问题整理\
    **1、python中的字符串和java一样，是不可变的

    a.  也就是说，python可以为变量赋数据，但实际上变量并不包含所赋的数据，而只是对数据对象的引用



2.  python同样内置了内存管理技术，会回收不再使用的RAM

    a.  通过引用计数的方式进行垃圾回收

3.  locals()BIF会返回当前作用域中定义的所有名的一个集合，可以这么使用：

    a.  if ‘变量名’ in locals()



4.  **异常作为对象传入except组：**



1.  类似于java，使用as给异常对象命名

    except IOError as err:

2.  通过str()BIF把异常对象转化（或者说强制转化）为字符串：

    print(str(err))


